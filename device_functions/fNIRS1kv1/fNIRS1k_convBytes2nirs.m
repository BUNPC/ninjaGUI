function [dataoutput,packlen,datac,statusdata]=fNIRS1k_convBytes2nirs(s,dev,SD)
% Converts the byte stream generated by NIRS1k to actual data
%datac is the complex data, dataoutput is the abs
%% hardware constants
N_OPTODES=dev.nDets;
N_WORDS_PER_DFT = 2;
N_BYTES_IN_DFT_WORD = 5;
N_FREQ = 8;
N_AUX = dev.nAux;
N_BYTES_PER_AUX = 2;

N_BYTES_TO_READ_PER_SAMPLE=N_WORDS_PER_DFT * N_BYTES_IN_DFT_WORD * (N_FREQ+1) +5; % N_FREQ+1 : for max/avg data; +3 for [channel, #bytes, DFT count];




%% DFT constants and data offsets

DFT_N=512;
KD = [56 60 64 70 80 84 96 105]; % demodulation k

offsetA = (0:N_FREQ-1)*N_BYTES_IN_DFT_WORD*N_WORDS_PER_DFT +3;
offsetB=offsetA+N_BYTES_IN_DFT_WORD;
wordpos=1:N_BYTES_IN_DFT_WORD;
part1=wordpos+offsetA';
part2=wordpos+offsetB';
powso256=256.^(0:N_BYTES_IN_DFT_WORD-1);
Kernel=exp(-1i*(2*pi/DFT_N)*KD(1:N_FREQ));

%% read bytes available as a multiple of bytes in the buffer and number of optodes (and aux)
fseek(s,0,'eof');
ba=ftell(s);
fseek(s,0,'bof');

%ba=15042300;

%this code helps prevent reading incomplete data packages
npacks=10;   %making this constant larger means we read less packets at a time, reducing processing overhead, but making it too large will affect refresh rate
rb=floor(ba/N_BYTES_TO_READ_PER_SAMPLE/(N_OPTODES+1)/npacks)*N_BYTES_TO_READ_PER_SAMPLE*(N_OPTODES+1)*npacks;

if rb>0
    raw = fread(s,rb,'uchar');
else
    dataoutput=[];
    packlen=0;
    datab=[];
    statusdata=[];
    return;
end


%% find indicator bytes
indicator=find(raw==N_BYTES_TO_READ_PER_SAMPLE-2);
packC=indicator-1;   %potential initial positions of data packets
packC(packC==0)=[];  %this means we missed the initial byte of one data packet

%% now, segregate candidate packages on data, aux or status

pAuxp=packC(raw(packC)==200); %possible aux positions
pStatp=packC(raw(packC)==254); %possible Status positions
pDatap=packC(raw(packC)>=0&raw(packC)<N_OPTODES); %possible detector positions

%% now look for the stop bytes; if they don't have them, then they are not data packages
%these are way more likely to be the actual positions of the data packages
pAuxp1=pAuxp(raw(min(pAuxp+93,end),:)==171&raw(min(pAuxp+94,end),:)==171);
pStatp1=pStatp(raw(min(pStatp+93,end),:)==172&raw(min(pStatp+94,end),:)==172);
pDatap1=pDatap(raw(min(pDatap+93,end-1),:)==170&raw(min(pDatap+94,end),:)==170);

pAux=pAuxp1;


%% initialize databuffer
ML=SD.measList;

rawN=size(raw,1);
maxsampN=ceil(length(pDatap1)/N_OPTODES)+2; %max number of samples possibly contained in the data package
datab=complex(nan(N_OPTODES,maxsampN,N_FREQ)); %complex data buffer
auxb=nan(N_AUX,maxsampN);  %aux data buffer

data=nan(size(ML,1),maxsampN); %buffer for intensity data
datac=complex(data);  %complex data







%% decode the optode data packets
Optind=pDatap1;
databm=complex(nan(maxsampN,N_FREQ));

for k=0:N_OPTODES-1
    indik=Optind(raw(Optind)==k);  %contain the indices of the potential data packages on raw for optode k
    
    seqk=raw(min(indik+2,end));  %contains the sequence data of potential data package; real data packages should be on a consecutive sequence
    
    try
        dataindk=indik([diff(seqk)==1|diff(seqk)==-255;~0]);  %indices on raw for the data points that are actually in sequence and are most likely data points, BUT there is lost data, one at each jump
    catch
        dataindk=indik(diff(seqk)==1|diff(seqk)==-255);  %probably not the most elegant solution
    end
    %the previous code is also potentially losing the last data point, but
    %1) doing that prevents errors, 2) it also prevents errors in the
    %likely case that it was truncated
    
    
    %% now, for each element of dataindk...
    mLength=size(dataindk,1);
    %databm=databm*nan;
    for m=1:mLength
        %% I need to actually convert the data package to intensity data
        indi1=dataindk(m):(dataindk(m)+N_BYTES_TO_READ_PER_SAMPLE-1); %indices for package
        if all(indi1<rawN)  %this check is to avoid incomplete data packages
            rawp=raw(indi1,:);
            %transform raw data to complex FT
            pnm1=sum(rawp(part1).*powso256,2)';
            indi=pnm1>(2^39-1);
            pnm1(indi)=pnm1(indi)-2^40;
            pnm0=sum(rawp(part2).*powso256,2)';
            indi=pnm0>(2^39-1);
            pnm0(indi)=pnm0(indi)-2^40;
            %             datab(k+1,m,:)=pnm0 - Kernel.*pnm1;
            databm(m,:)=pnm0 - Kernel.*pnm1;
        end
    end
    datab(k+1,:,:)=databm;
end

%% now decode the aux data packets
Auxind=pAux;
%discard incomplete aux packets
Auxind(Auxind+2>rawN)=[];


seqAux=raw(Auxind+2);  %contains the sequence data of potential aux packets

sbreaks=find(diff(seqAux)~=1&diff(seqAux)~=-255); %sequence breaks
sbreaks=sbreaks(2:2:end);  %mark the sequence breaking packages

Auxdataindk=Auxind;
Auxdataindk(sbreaks)=[]; %delete the sequence breaking offenders


% try
%     Auxdataindk=Auxind([diff(seqAux)==1|diff(seqAux)==-255;~0]);  %again, will lose data at each jump :(, and the last one of the data package
% catch
%     %     disp('This is a bug!')
%     Auxdataindk=[];
% end
pows256b=256.^(0:N_BYTES_PER_AUX-1)';

for m=1:length(Auxdataindk)
    indi1=Auxdataindk(m):Auxdataindk(m)+92;
    if all(indi1<rawN)
        rawp=raw(indi1,:);
        %extract the raw data info from data package
        offset=((1:N_AUX)-1)*N_BYTES_PER_AUX +3;
        auxb(:,m) = sum(rawp(offset+(1:N_BYTES_PER_AUX)') .* pows256b)'; %this line of code will only work in newer versions of matlab, sorry!
    end
end

%% now decode the status packages
Statind=pStatp1;
%assumes all potential status packages ARE status packages (less
%computationally expensive), and the status packages are not precious data!
statusdata=nan(length(Statind));

for m=1:length(Statind)
    indi1=Statind(m):Statind(m)+92;
    if all(indi1<rawN)
        rawp=raw(indi1);
        %extract the raw data info from data package
        statusdata(m) = sum(rawp(2:3) .*  256.^(0:1)');
    end
end


%% select which data channels we are actually interested in based on sd file


frequs=2*(ML(:,1)-1)+(3-ML(:,4));  %frequencies are fixed per source, so easy to calculate

for k=1:size(ML,1)
    datac(k,:)=(datab(ML(k,2),:,frequs(k)));
end
data=abs(datac);


%% finally, prepare data output

dataoutput=[data;auxb];
indice=~all(isnan(dataoutput));
dataoutput=dataoutput(:,indice); %eliminate columns with no data
datac=datac(:,indice);

packlen=size(dataoutput,2); %number of samples in data package

%fclose(s)